# ================================================================
# gui_parser.py (统一风格 + 背景滤波 + DBSCAN + 人体追踪)
# ---------------------------------------------------------------
# 功能：
#   1️⃣ 实时接收点云帧并保存为 xlsx
#   2️⃣ 使用 BGNoiseFilter 进行背景噪声过滤
#   3️⃣ 进行 DBSCAN 聚类并保存结果（含防损坏逻辑）
#   4️⃣ 使用 HumanTracking 模块进行人体轨迹追踪
#   5️⃣ 将结果通过 pointcloud_notifier 通知 GUI
# ================================================================

import os
import sys
import time
import datetime
import pandas as pd
import numpy as np
import serial

from pointcloud_notifier import notify_new_pointcloud
from library.parseFrame import *
from library.DBSCAN_generator import DBSCANGenerator
from library.bgnoise_filter import BGNoiseFilter
from library.human_tracking import HumanTracking


class uartParser:
    def __init__(self, type='SDK Out of Box Demo', out_bin_dir=None, out_xlsx_dir=None):
        """UART 解析器初始化"""
        self.saveBinary = 0
        self.replay = 0
        self.binData = bytearray()
        self.uartCounter = 0
        self.framesPerFile = 5
        self.first_file = True
        self.filepath = datetime.datetime.now().strftime("%m_%d_%Y_%H_%M_%S")
        self.pointCloudCache = []

        self.out_bin_dir = out_bin_dir
        self.out_xlsx_dir = out_xlsx_dir

        # ------------------- 类型判断 -------------------
        if type in [DEMO_NAME_OOB, DEMO_NAME_LRPD, DEMO_NAME_3DPC,
                    DEMO_NAME_SOD, DEMO_NAME_VITALS, DEMO_NAME_MT, DEMO_NAME_GESTURE]:
            self.parserType = "DoubleCOMPort"
        elif type in [DEMO_NAME_x432_OOB, DEMO_NAME_x432_GESTURE]:
            self.parserType = "SingleCOMPort"
        elif type == "Replay":
            self.replay = 1
        else:
            print("[ERROR] Unsupported demo type selected!")

        # ------------------- 模块配置 -------------------
        cfg = {
            'DBSCAN_GENERATOR_CFG': {
                'Default': {
                    'DBS_eps': 0.5,
                    'DBS_min_samples': 10,
                    'DBS_cp_pos_xlim': None,
                    'DBS_cp_pos_ylim': None,
                    'DBS_cp_pos_zlim': (-1.8, 1.8),
                    'DBS_size_xlim': (0.2, 1),
                    'DBS_size_ylim': (0.2, 1),
                    'DBS_size_zlim': (0.0, 2),
                    'DBS_sort': 3,
                }
            },
            'BGNOISE_FILTER_CFG': {
                'BGN_enable': True,
                'BGN_deque_length': 50,
                'BGN_accept_SNR_threshold': (None, 200),
                'BGN_filter_SNR_threshold': (None, 200),
                'BGN_DBS_window_step': 50,
                'BGN_DBS_eps': 0.06,
                'BGN_DBS_min_samples': 5,
                'BGN_cluster_tf': 0.05,
                'BGN_cluster_xextension': 0.05,
                'BGN_cluster_yextension': 0.05,
                'BGN_cluster_zextension': 0.05,
            },
            'HUMAN_TRACKING_CFG': {
                'TRK_enable': True,
                'TRK_obj_bin_number': 2,
                'TRK_poss_clus_deque_length': 3,
                'TRK_redundant_clus_remove_cp_dis': 1,
            },
            'HUMAN_OBJECT_CFG': {
                'obj_deque_length': 60,
                # the length of central point, size and status info in timeline stored in object bin

                # object update possibility config
                # related_possibility, hard limit
                'dis_diff_threshold': {
                    'threshold': 0.8,
                    # the distance threshold(m) between the current cp and previous one for object info update
                    'dynamic_ratio': 0.2,  # the speed ratio for dynamic distance threshold, 0-do nothing
                },
                'size_diff_threshold': 1,
                # the size diff threshold(m^3) between the current cp and previous one for object info update
                # self_possibility, soft limit, (hard limit is set in DBSCAN_min/max_size), this is also used for classify the status
                'expect_pos': {
                    'default': (None, None, 1.1),
                    'standing': (None, None, 1.1),
                    'sitting': (None, None, 0.7),
                    'lying': (None, None, 0.5),
                },
                'expect_shape': {
                    'default': (0.8, 0.8, 1.8),
                    'standing': (0.7, 0.7, 1.5),
                    'sitting': (0.3, 0.3, 0.6),
                    'lying': (0.8, 0.8, 0.4),
                },
                'sub_possibility_proportion': (1, 1, 1, 1),  # the coefficient for the possibility proportion
                'inactive_timeout': 5,  # second, if timeout, object bin status goes inactive
                'obj_delete_timeout': 60,  # second, if timeout, delete this object bin

                # an entrance zone, for object bin start picking up an object
                'fuzzy_boundary_enter': False,
                'fuzzy_boundary_threshold': 0.5,
                'scene_xlim': (-4,4),
                'scene_ylim': (0,8),
                'scene_zlim': (-4,4),

                # object status threshold
                'standing_sitting_threshold': 0.9,
                'sitting_lying_threshold': 0.4,

                # get last update 2-5 info to show the current position and status
                'get_fuzzy_pos_No': 20,
                'get_fuzzy_status_No': 40,
            },
        }

        # ------------------- 模块初始化 -------------------
        self.dbscan = DBSCANGenerator(**cfg)
        self.bgn = BGNoiseFilter(**cfg)
        self.tracker = HumanTracking(
            HUMAN_TRACKING_CFG=cfg['HUMAN_TRACKING_CFG'],
            HUMAN_OBJECT_CFG=cfg['HUMAN_OBJECT_CFG']
        )

        # 输出路径
        if self.out_xlsx_dir:
            self.cluster_dir = os.path.join(self.out_xlsx_dir, "cluster_xlsx")
            os.makedirs(self.cluster_dir, exist_ok=True)
        else:
            self.cluster_dir = None

    # ------------------- 公共方法 -------------------
    def setSaveBinary(self, saveBinary: int):
        self.saveBinary = saveBinary
        print(f"saveBinary set to: {self.saveBinary}")


    # ================================================================
    # 串口模式
    # ================================================================
    def readAndParseUartDoubleCOMPort(self):
        """双串口读取 + 背景滤波 + DBSCAN 聚类 + 人体追踪"""
        self.fail = 0
        if self.replay:
            return self.replayHist()

        index = 0
        magicByte = self.dataCom.read(1)
        frameData = bytearray()

        # --- 帧头识别 ---
        while True:
            if len(magicByte) < 1:
                magicByte = self.dataCom.read(1)
            elif magicByte[0] == UART_MAGIC_WORD[index]:
                index += 1
                frameData.append(magicByte[0])
                if index == 8:
                    break
                magicByte = self.dataCom.read(1)
            else:
                if index == 0:
                    magicByte = self.dataCom.read(1)
                index = 0
                frameData = bytearray()

        # --- 读取帧体 ---
        frameData += self.dataCom.read(4)  # version
        lengthBytes = self.dataCom.read(4)
        frameData += lengthBytes
        frameLength = int.from_bytes(lengthBytes, 'little') - 16
        frameData += self.dataCom.read(frameLength)

        # ================================================================
        # ✅ Step1: 解析帧
        # ================================================================
        if self.saveBinary == 1:
            self.binData += frameData
            self.uartCounter += 1
            outputDict = parseStandardFrame(frameData)
            frame_df = pd.DataFrame(
                outputDict["pointCloud"],
                columns=['X', 'Y', 'Z', 'Doppler', 'SNR', 'Noise', 'Track index']
            )
            self.pointCloudCache.append(frame_df)

            # 缓存控制
            if len(self.pointCloudCache) > self.framesPerFile:
                self.pointCloudCache.pop(0)

            # ================================================================
            # ✅ Step2: 到达缓存上限后处理
            # ================================================================
            if len(self.pointCloudCache) == self.framesPerFile:
                if self.first_file:
                    os.makedirs(self.out_bin_dir, exist_ok=True)
                    os.makedirs(self.out_xlsx_dir, exist_ok=True)
                    self.first_file = False

                # 保存 bin 文件
                file_bin = os.path.join(self.out_bin_dir, f"pHistBytes_{self.uartCounter}.bin")
                with open(file_bin, 'wb') as bfile:
                    bfile.write(bytes(self.binData))
                self.binData = bytearray()

                # 合并帧数据
                all_points = pd.concat(self.pointCloudCache, ignore_index=True)
                data_np = all_points[['X', 'Y', 'Z', 'Doppler', 'SNR']].to_numpy(dtype=np.float32)

                # ================================================================
                # ✅ Step3: 背景滤波
                # ================================================================
                self.bgn.BGN_update(data_np)
                filtered_data = self.bgn.BGN_filter(data_np)
                print(f"[BGN] 原始点数: {data_np.shape[0]}, 滤波后: {filtered_data.shape[0]}")

                filtered_df = pd.DataFrame(filtered_data, columns=['X', 'Y', 'Z', 'Doppler', 'SNR'])
                file_xlsx = os.path.join(self.out_xlsx_dir, f"pHistBytes_{self.uartCounter}.xlsx")
                filtered_df.to_excel(file_xlsx, index=False)
                print(f"[Save] 滤波点云已保存 -> {file_xlsx}")

                # ================================================================
                # ✅ Step4: DBSCAN 聚类 + 空文件保护
                # ================================================================
                cluster_path = None
                valid_points_list = []
                try:
                    _, valid_points_list, _, noise = self.dbscan.DBS(filtered_data)
                    cluster_path = os.path.join(self.cluster_dir, f"cluster_{self.uartCounter}.xlsx")

                    with pd.ExcelWriter(cluster_path, engine="openpyxl") as writer:
                        if len(valid_points_list) == 0 and len(noise) == 0:
                            pd.DataFrame(columns=['X', 'Y', 'Z', 'Doppler', 'SNR']).to_excel(
                                writer, sheet_name='Empty', index=False)
                            print(f"[DBSCAN] 无聚类结果 -> {cluster_path}")
                        else:
                            for i, cluster in enumerate(valid_points_list):
                                if len(cluster) == 0:
                                    continue
                                df_cluster = pd.DataFrame(cluster, columns=['X', 'Y', 'Z', 'Doppler', 'SNR'])
                                df_cluster.to_excel(writer, sheet_name=f'Cluster_{i + 1}', index=False)
                            if len(noise) > 0:
                                df_noise = pd.DataFrame(noise, columns=['X', 'Y', 'Z', 'Doppler', 'SNR'])
                                df_noise.to_excel(writer, sheet_name='Noise', index=False)
                            print(f"[DBSCAN] 聚类结果已保存 -> {cluster_path}")

                except Exception as e:
                    print(f"[DBSCAN ERROR] {e}")

                # ================================================================
                # ✅ Step5: 人体追踪
                # ================================================================
                track_positions = []
                try:
                    if len(valid_points_list) > 0:
                        self.tracker.TRK_update_poss_matrix(valid_points_list)
                        for person in self.tracker.TRK_people_list:
                            obj_cp, _, _ = person.get_info()
                            if obj_cp.size > 0:
                                track_positions.append(obj_cp.flatten().tolist())
                except Exception as e:
                    print(f"[Tracking ERROR] {e}")

                # ================================================================
                # ✅ Step6: 通知 GUI
                # ================================================================
                notify_new_pointcloud((file_xlsx, cluster_path, filtered_data, track_positions))

        return parseStandardFrame(frameData)

    # ------------------- 单串口模式 -------------------
    def readAndParseUartSingleCOMPort(self):
        if not self.cliCom.isOpen():
            self.cliCom.open()

        self.fail = 0
        if self.replay:
            return self.replayHist()

        index = 0
        magicByte = self.cliCom.read(1)
        frameData = bytearray()

        # --- 帧头识别 ---

        return parseStandardFrame(frameData)

    # ------------------- 串口连接 -------------------
    def connectComPorts(self, cliCom, dataCom):
        self.cliCom = serial.Serial(cliCom, 115200, parity=serial.PARITY_NONE,
                                    stopbits=serial.STOPBITS_ONE, timeout=0.6)
        self.dataCom = serial.Serial(dataCom, 921600, parity=serial.PARITY_NONE,
                                     stopbits=serial.STOPBITS_ONE, timeout=0.6)
        self.dataCom.reset_output_buffer()
        print('Connected')

    def connectComPort(self, cliCom, cliBaud=115200):
        self.cliCom = serial.Serial(cliCom, cliBaud, parity=serial.PARITY_NONE,
                                    stopbits=serial.STOPBITS_ONE, timeout=4)
        self.cliCom.reset_output_buffer()
        print('Connected (one port)')

    # ------------------- 配置下发 -------------------
    def sendCfg(self, cfg):
        for i, line in enumerate(cfg):
            if line == '\n':
                cfg.remove(line)
            elif line[-1] != '\n':
                cfg[i] = line + '\n'

        for line in cfg:
            time.sleep(.03)
            if self.cliCom.baudrate == 1250000:
                for char in [*line]:
                    time.sleep(.001)
                    self.cliCom.write(char.encode())
            else:
                self.cliCom.write(line.encode())

            ack = self.cliCom.readline(); print(ack)
            ack = self.cliCom.readline(); print(ack)

            splitLine = line.split()
            if splitLine[0] == "baudRate":
                try:
                    self.cliCom.baudrate = int(splitLine[1])
                except:
                    print("Error - Invalid baud rate")
                    sys.exit(1)

        time.sleep(0.03)
        self.cliCom.reset_input_buffer()

    def sendLine(self, line):
        self.cliCom.write(line.encode())
        ack = self.cliCom.readline(); print(ack)
        ack = self.cliCom.readline(); print(ack)


def getBit(byte, bitNum):
    mask = 1 << bitNum
    return 1 if byte & mask else 0
